---
title: "Basic Data Structures"
author: "Maria Kechagia"
date: "18/10/2017"
output:
  ioslides_presentation: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Sets

In mathematics, a **set** is a collection of *distinct* elemets.

![](./figures/set-of-shapes.svg)

## Dynamic Sets

- Sets can be manipulated using appropriate algorithms.
Then, sets can grow, shrink, or change over time.

- Dynamic sets can support basic operations such as:
*insert* elements to a set, *remove* elements from a set,
or *search* whether an element belongs to a set.

```script
  insert(S, x)
  # Add an element to a set S pointed to by x.
```

```script
  remove(S, x)
  # Given a pointer x to an element in a set S, remove x from S.
```

```script
  search(S, k)
  # Given a set S and a key k, return a pointer x to an element in S.
  # Output: x.key = k or NIL.
```

## Stacks and Queues (1)

- Stacks and queues are *abstract data types* that represent *dynamic sets*,
where the way an element can be removed from a set is prespecified.

- In a **stack**, the element to be removed is the one that was most recently inserted into the stack. We name this policy as: *last-in, first-out*, or *LIFO*.

- If a **stack** consists of elements ```S[1..S.top]```, ```S[1]``` is the element at the *bottom* of the stack and ```S[S.top]``` is the element at the *top* of the stack. If ```S.top = 0```, the stack is *empty*.

## Stacks and Queues (2)

- In a **queue**, the element to be removed is the one that belongs to the set for the longest time. We name this policy as: *first-in, first-out*, or *FIFO*.

- If a **queue** consists of elements ```Q[1..n]```, ```Q.heap``` points to its *head* and ```Q.tail``` points the *next* position where a new element can be added to the queue. When ```Q.heap = Q.tail```, it means that the queue is *empty*.

## Stack Operations

- The `insert` operation on a stack is called as `push`.
Additionally, the `remove` operation is called as `pop`.

- The `top` operation on a stack
returns that most recently added element.

- The `empty` operation checks
whether the stack is empty.

## Stack Implementation with Array

- Which is the top element in the stack below?
```{r echo=FALSE}
  # The top element is the 4th one.
  x <- matrix(list(15,6,2,9,"N","N","N"), nrow = 1, dimnames = list(c("S"), c("[1]","[2]","[3]","[4]","[5]","[6]","[7]")))
  x
```
- In which positions of the following stack,
new elements 17 and 3 are going to be added?
```{r echo=FALSE}
  # New elements (5th and 6th) are added to the end of the stack.
  x <- matrix(list(15,6,2,9,17,3,"N"), nrow = 1, dimnames = list(c("S"), c("[1]","[2]","[3]","[4]","[5]","[6]","[7]")))
  x
```
- If we remove the 6th element of the following stack,
which will be the top one?
```{r echo=FALSE}
  # When the 6th element is removed, the next top element is the 5th
  x <- matrix(list(15,6,2,9,17,"[3]","N"), nrow = 1, dimnames = list(c("S"), c("[1]","[2]","[3]","[4]","[5]","[6]","[7]")))
  x
```

## Queue Operations

- The `insert` operation on a queue is called as `enqueue`.
Additionally, the `remove` operation is called as `dequeue`.

## Queue Implementation with Array

- Which are the *head* and *tail* of the following queque?
```{r echo=FALSE}
  # Q.tail = 7 and Q.head = 12
  x <- matrix(list("N","N","N","N","N","N",15,6,9,8,4,"N"), nrow = 1, dimnames = list(c("S"), c("[1]","[2]","[3]","[4]","[5]","[6]","[7]","[8]","[9]","[10]","[11]","[12]")))
  x
```
- If we add elements to the positions $3-6$,
which are going to be the *head* and *tail* of the following queque?
```{r echo=FALSE}
  # Q.tail = 3 and Q.head = 7
  x <- matrix(list(3,5,"N","N","N","N",15,6,9,8,4,17), nrow = 1, dimnames = list(c("S"), c("[1]","[2]","[3]","[4]","[5]","[6]","[7]","[8]","[9]","[10]","[11]","[12]")))
  x
```
- If we remove the $5th$ element,
which are going to be the *head* and *tail* of the following queque?
```{r echo=FALSE}
  # Q.tail = 3 and Q.head = 8
  x <- matrix(list(3,5,"N","N","N","N","[15]",6,9,8,4,17), nrow = 1, dimnames = list(c("S"), c("[1]","[2]","[3]","[4]","[5]","[6]","[7]","[8]","[9]","[10]","[11]","[12]")))
  x
```

## Lists

A **list** is a data structure that can store
items (usually) of the same type and
in a specific order.

Typically, we can create a list
by writing the values (items) we want to store
in a comma-separated list.

$1, 2, 3, 4, 5$

## Linked Lists

- A **linked list** is a data structure where objects
are arranged in a linear order and this order is determined
by poiters attached to each element of the list.

- There are two types of linked lists: *doubled* and *singly*.

- Linked lists support *all* the operations of dynamic sets.

## Doubly Linked Lists

- A **doubly linked list** ```L``` represents a dynamic set ```{1, 4, 9, 16}```,
where the attribute ```L.heap``` points to the head of the list
and ```L.tail``` points the last element of the list
(where after this there is no *next* element).
If ```L.heap = NIL```, it means that the list is *empty*.

- Given that ```x``` is an element of a list ```L```, 
```x.next``` points to the successor element of ```x```
and ```x.prev``` points to the predecessor element of ```x```.

## More Forms of Linked Lists

- If a list is **singly linked**, the ```prev``` pointer is omitted.

- If a list is **ordered**, the elements of the list
are arranged in linear order.
Then, the minimum element is the *head* of the list,
whereas the maxinum element is the *tail* of the list.

- If a list is **cincular**,
the ```prev``` pointer of the head of the list points to its tail,
and the ```next``` pointer of the tail of the list points to its head.

## Representation of Data Structures in Computer Memory

An **array** is allocated as one block of memory.
Each array element has its own space in the array and it can be directly accessed
using the ```[]``` syntax.
The following figure illustrates how an array might look like in memory.

![](./figures/array-memory.png)

## Disadvantages of Arrays (1)

The size of the arrays is *fixed*.
This means that this size is known at compile time.

To avoid the above case, we can declare arrays
with more capasity, in case we need this in the future.

Even though this strategy can be convenient,
we maybe have wasted space in the array.
Also, if we finally need to process much more elements
than the capacity of the array,
the code will break.

## Disadvantages of Arrays (2)

Inserting new elements at the front of the array is expensive,
because the already stored elements need to be shifted over to make room
to the new added elements.

To overcome these problems,
we can use **linked lists**
that separately allocate memory for each element,
when it is actually necessary.

## Linked List in Memory

Contrary to arrays that allocate memory for all its elements
together in block of memory,
linked lists *separately* allocate space for *each* element
in its own block of memory called as "linked list element" or "node".

The list uses *pointers* to connect all its nodes together
(i.e. such as the links in a chain).

## Linked List Nodes

Each *node* has two fields.
A "data" field that stores the element and a "next" field,
which is the pointer to the next node.
Each node is allocated in the *heap*.

![](./figures/ll-memory.png)

## Implementation of a Linked List in Python

In order to implement a linked list in Python,
we need to create a **Node**
that will be store *data* and a *reference* to the next node.

## The Class Node

```python
class Node:
    def __init__(self,initdata):
        self.data = initdata
        self.next = None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data = newdata

    def setNext(self,newnext):
        self.next = newnext
```

## The New Node

```python
>>> temp = Node(93)
>>> temp.getData()
93
```

![](./figures/node.png)

## An Unordered List Class

```python
class UnorderedList:

    def __init__(self):
        self.head = None
        
    def isEmpty(self):
      return self.head == None
      
    def add(self,item):
      temp = Node(item)
      temp.setNext(self.head)
      self.head = temp
```

## The New List

```python
>>> mylist.add(31)
>>> mylist.add(77)
>>> mylist.add(17)
>>> mylist.add(93)
>>> mylist.add(26)
>>> mylist.add(54)
```

![](./figures/ll.png)

## Linked List Traversal

- Methods that implement operations, such as ```size```, ```search```, and ```remove```,
are based on a technique that is called as **linked list traversal**.

- Traversal refers to the process of systematically visiting each node of the list.
To achieve this, we use an external reference that starts from the first node of the list,
and we continue the passage.

- In particular, we visit one node, and then we move the reference to the next node by
"traversing" the next reference.

## List Size

- To implement the ```size``` method,
we need to traverse the linked list,
counting the nodes of the list.

- In the beginning, the counter (```current```) is set to ```0```,
because there is not currely any node.

- We continue checking for new nodes
until the ```current``` reference reaches the end of the list (```None```).

```python
def size(self):
    current = self.head
    count = 0
    while current != None:
        count = count + 1
        current = current.getNext()

    return count
```

## Searching in a List

To implement the ```search``` method,
we develop the following strategy.
We visit each node of the list and we check
whether this node has stored the data
that we are looking for.
We conduct this process
until we find the appropriate node.

```python
def search(self,item):
    current = self.head
    found = False
    while current != None and not found:
        if current.getData() == item:
            found = True
        else:
            current = current.getNext()

    return found
```

## Search for an Element

```python
>>> mylist.search(17)
True
```

Here, the traversal needs to move up to the
node that contains the element ```17```.

![](./figures/search-ll.png)

## Remove an Element

To implement the remove method,
we need to perform two passes.

- First, we *traverse* the list until
we find the element to be removed.
This step is similar with the traversal
we conduct for the ```search``` method.

- Second, we *update* the nodes that
contain the references to the elements.
If we remove the node,
how can we update the links to the next nodes? 

## The ```previous``` Reference

Since a linked list does not premits
backwards traversal,
we use two external references.

The first reference is the ```current``` one
that represents the current location of the traverse,
and the second reference is the ```previous``` one
that represents a node *behind* the ```current```.

XX: To add a figure here.

## The ```remove``` Method

```python
def remove(self,item):
    current = self.head
    previous = None
    found = False
    while not found:
        if current.getData() == item:
            found = True
        else:
            previous = current
            current = current.getNext()

    if previous == None:
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
```

## Maps

A map is an abstract data structure that stores
key-value pairs and
there cannot be duplicate keys.

Such a data structure is also called as:
*associative array*, *symbol table*, or *dictionary*.

Maps are usuful in order to:

- store objects to specific keys, and

- lookup of the values associated with a particular key.

## An Example of a Map

![](./figures/dictionary.png)

## Operations of the Map Data Type

- The method `put` adds a new key-value pair to a map.
If the `key` is already in the map, it replaces the old value for that key.

- The method `get` returns the value of that key,
or `None` if there is no value.

- The method `delete` removes a key-value pair from a map.

## Implementation of a Map

- Arrays

- Linked-lists

- Binary search trees

- Hash tables

## A Linked List Implementation of a Map

We can store key-value pairs in a linked list
as it is illustrated in the following figure.

![](./figures/map-ll.png)

## Basic Operations

- `get(k)`:
It iterates the list until
it finds the item with key `k`.

- `put(k, v)`: Given Node `x = get(k)`,
if `x` exists, it replaces the value of `x` with `v`.
Otherwise, it creates a new `node(k,v)`
and adds this at the front of the list.

- `remove(k)`: Given Node `x = get(k)`,
if `x` does not exist, it returns `null`.
Otherwise, it removes node `x` from the list.

- Complexity: $O(n)$ on a map with $n$ elements.

## Implementing Maps Using Hashing

- Can we do better in complexity terms?

- Yes, by building a type of a data structure
that can search in $O(1)$ time.
This can be achieved with a concept called as **hashing**.

## Hash Tables

- A **hash table** is a collection of elements
that are stored in such a way
that it is easy for one to find them later.

- The positions of a hash table start from $0$
and at each position, it can store an item.

- The **mapping** between an element and a slot in the collection,
where an element belongs to is called **hash function**.
However, we are going to talk in another lecture about it.

## Initialization of a Hash Table

- We are initializing a hash table
by adding the special Python `None` value
to the slots of the table.

![](./figures/hash-map.png)

## How does it work?

- Assume that we have the set $S= {54,26,93,17,77,31}$
and we want to add the items into a hash table of size $11$.

- A simple hash function takes an item and
divides it by the table size.

- The remainder is the hash value,
which will indicate the positions
where the items will be inserted in the hash table.

XX: To add the hash table here.

## Implementation of Map in Python

```python
class HashTable:
    def __init__(self):
        self.size = 11
        self.slots = [None] * self.size
        self.data = [None] * self.size
```

## Put Values

```python
def put(self,key,data):
  hashvalue = self.hashfunction(key,len(self.slots))

  if self.slots[hashvalue] == None:
    self.slots[hashvalue] = key
    self.data[hashvalue] = data
  else:
    if self.slots[hashvalue] == key:
      self.data[hashvalue] = data  #replace
    else:
      nextslot = self.rehash(hashvalue,len(self.slots))
      while self.slots[nextslot] != None and \
                      self.slots[nextslot] != key:
        nextslot = self.rehash(nextslot,len(self.slots))

      if self.slots[nextslot] == None:
        self.slots[nextslot]=key
        self.data[nextslot]=data
      else:
        self.data[nextslot] = data #replace

def hashfunction(self,key,size):
     return key%size

def rehash(self,oldhash,size):
    return (oldhash+1)%size
```

## Get Values

```python
def get(self,key):
  startslot = self.hashfunction(key,len(self.slots))

  data = None
  stop = False
  found = False
  position = startslot
  while self.slots[position] != None and  \
                       not found and not stop:
     if self.slots[position] == key:
       found = True
       data = self.data[position]
     else:
       position=self.rehash(position,len(self.slots))
       if position == startslot:
           stop = True
  return data

def __getitem__(self,key):
    return self.get(key)

def __setitem__(self,key,data):
    self.put(key,data)
```
