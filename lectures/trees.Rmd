---
title: "Trees"
date: "`r Sys.Date()`"
author: Joseph Hejderup
output: revealjs::revealjs_presentation
bibliography: bibliography.bib
csl: ieee.csl
---

```{r child="header.Rmd", include=FALSE}
```

# Tree as a data structure {data-background="figures/tree_american.jpg"}

## Why organize data as a tree structure?

- Humans have a natural inclination towards hierarchical thinking and this have
  had a profound impact on the way we reason, decide and look at *things*
- Examples are social and political structures such as *family tree*,
  *governance* and *species* 
- Introducing *order* such as *hierarchical order* to data allows computers
  to make decisions in a much more efficient way then linear data
  structures


## Example: Visiting a distant aunt
What do we know about this aunt and our family:

- You only meet her once every three years
- She is from your **dad's side**
- There is a huge family gathering next week and you have been asked to find her
  address.


## Example: Visiting a distant aunt (1)
- Equipped with the knowledge from the previous week, we would organize family
  relatives in the following fashion:

![](./figures/tree_linear.svg)

## Example: Visiting a distant aunt (2)
Knowing the hierarchical **order** of our family, we would prefer making a
family tree!

![](./figures/tree_nonlinear.svg)

## Introducing the notion of *order* to a dataset

- Provides the computer additional insights on the relation between data values
- Allows the computer to examine the relationship between data values and make
  decisions based on them
- This makes lookup for a data value much faster, we can avoid examine a large
  chunk of the data set
- In the example, we knew the aunt was on the dad's side and thus avoided
  looking into mom's side of relatives!
- A tree is an example of organizing data values according to an **order** (e.g
  hierarchical order)

<!-- How can we integrate *order* in a data structure? -->

## Tree terminology (1)
![](./figures/tree_def.svg)

## Tree Properties (1)
A tree constitute with the following properties:

* A single & special node named **root**, start node on top of tree and does not have a **parent**
* Succeeding nodes can be either a **child** or **parent**
 + A **child** node is connected by *at-least* a preceding node
 + The *preceding* node is known as a **parent** node
 + A **parent** node has *zero, one or more* children(successor nodes)

## Tree terminology (2)
![](./figures/tree_def_2.svg)

## Tree Properties (2)

* All nodes in a tree (except the **root**) are child nodes
* **Siblings** are nodes with the same **parent**
* **Subtree** are the descendants of a node
* A node without children is a **leaf** node

## Tree Height

![](./figures/tree_height.svg)

## Tree Depth

![](./figures/tree_depth.svg)

## Path 
![](./figures/tree_path.svg)


## Traversal Methods
Linear data structures have only one way to read data; a tree can be traversed
in two ways: **depth-first** and **breath-first**(discussed next week). Three
depth-first methods:

* Pre-order
* In-order
* Post-order

## Traversal Methods (1)

![](./figures/tree_traversal_intro.svg)


## Traversal Methods (3)

### Pre-order traversal
Visit this recursively 
```
root node => left sub-tree => right sub-tree
```
###In-order traversal
```
left sub-tree => root node => right sub-tree
```
### Post-order traversal
```
left sub-tree => right sub-tree => root node
```
# Binary Trees  {data-background="figures/tree_binary_intro.svg"}

## Properties

- A Binary tree is a *2-ary* tree with zero, one or two *children* (left or
    right)
- The structure is simple and forms more of a "decision" tree, where each step
  resembles a yes or no answer
- This makes it efficient for sorting and searching 
  
- The depth of a node is the number of edges from the root to the node.
- The height of a node is the number of edges from the node to the deepest leaf.
- The height of a tree is a height of the root.
- A full binary tree.is a binary tree in which each node has exactly zero or two
  children.
- A complete binary tree is a binary tree, which is completely filled, with the
  possible exception of the bottom level, which is filled from left to right.

## Implementation

```python
class BinaryTree():

    def __init__(self,rootid):
      self.left = None
      self.right = None
      self.rootid = rootid

    def getLeftChild(self):
        return self.left
    def getRightChild(self):
        return self.right
    def setNodeValue(self,value):
        self.rootid = value
    def getNodeValue(self):
        return self.rootid

```

## Adding elements to the tree

```python

    def insertRight(self,newNode):
        if self.right == None:
            self.right = BinaryTree(newNode)
        else:
            tree = BinaryTree(newNode)
            tree.right = self.right
            self.right = tree

    def insertLeft(self,newNode):
        if self.left == None:
            self.left = BinaryTree(newNode)
        else:
            tree = BinaryTree(newNode)
            tree.left = self.left
            self.left = tree
```


## Does shape matter?

Short Answer: YES!

- The depth of the tree impacts the time of traversing a tree
- The order in which we add elements matters, the shape it can take, is shown in
  the next slide

## Three different types of a tree?
![](./figures/tree_types.svg)


## Binary Search Trees (BST)
- As the name indication, it provides means to search in a Binary Tree
  structure
- A binary tree is a Binary Search tree if the value of the node is greater the
  values of each node in the left subtree and smaller than the values of each
  node in the right subtree

## Example of a BST  

![](./figures/tree_bst.svg)


## Searching in a Binary Search Tree

If we are looking for element X:

1. Compare current node's key with X. If it's equal, we've found the key. All
   done.
2. If X is less than node's key, we start looking at node's left subtree. It's
   because we know that right subtree cannot contain anything greater than X.
3. If X is greater than node's key, we start looking in the right subtree.
4. We repeat this process until we find the key or we reach the leaf node. If we
   reach the leaf node and haven't found the key as yet, we return not found.

## Example: Lookup value 49 in a BST

![](./figures/tree_bst_search_1.svg)

## Example: Lookup value 49 in a BST

![](./figures/tree_bst_search_2.svg)

## Example: Lookup value 49 in a BST

![](./figures/tree_bst_search_3.svg)


## Inserting a value into a BST

1. Compare current node's key with K.
2. If K is less than the current node,
    1. If left child of current node is Null, we insert K as the left child of
    current node and return.
    2. If the left child is not Null, the left child becomes the new current
       node, and we repeat the process from step 1.
3. If K is greater than the current node,
    1. If right child of current node is Null, we insert K as the right child of
       the current node and return.
    2. If the right child is not Null, the right child becomes the new current
       node, and we repeat the process from step 1.

## Inserting a value into a BST

![](./figures/tree_bst_in_1.svg)

## Inserting a value into a BST

![](./figures/tree_bst_in_2.svg)

## Inserting a value into a BST

![](./figures/tree_bst_in_3.svg)

## Inserting a value into a BST

![](./figures/tree_bst_in_4.svg)

## Inserting a value into a BST

![](./figures/tree_bst_in_5.svg)

## Inserting a value into a BST

![](./figures/tree_bst_in_6.svg)

## Removing a value from a BST

When we have to delete a node with two children, we have two options. Let's say
that the node to be deleted has key X.

1. Replace the current node's key with its predecessor and then trigger delete
   for predecessor in node's left subtree.
2. Replace the current node's key with its successor and then trigger delete for
   predecessor in node's right subtree.

## Removing 40 from the BST Example

![](./figures/tree_rm_1.svg)


## Removing 40 from the BST Example

![](./figures/tree_rm_2.svg)

## Removing 40 from the BST Example

![](./figures/tree_rm_3.svg)


# Self-balancing binary search tree

## 

A self-balancing binary search tree or height-balanced binary search tree is a
binary search tree (BST) that attempts to keep its height, or the number of
levels of nodes beneath the root, as small as possible at all times,
automatically.

- Most operations on a BST take time proportional to the height of the tree, so it
is desirable to keep the height small.

- Self-balancing binary trees solve this problem by performing transformations on
the tree at key times, in order to reduce the height. Although a certain
overhead is involved, it is justified in the long run by ensuring fast execution
of later operations.

- The height must always be at most the ceiling of log2n.

- Balanced BSTs are not always so precisely balanced, since it can be expensive to
keep a tree at minimum height at all times; instead, most algorithms keep the
height within a constant factor of this lower bound.

## Typical Binary Tree

``` python
class Node:
   """
   AVL Tree Node class
   """

   def __init__(self, key):
      """
      Node constructor
      """
      self.left = None
      self.right = None
      self.key = key

   def __str__(self):
      return "%s" % self.key
```

## AVL Tree

``` python
class AVLTree():
    """
    Implementation of AVL tree
    """
    def __init__(self):
        self.node = None
        self.height = -1
        self.balance = 0
```

## Insertion

```python
    def insert(self, key):
        """
        Insert new key into node
        """
        # Create new node
        n = Node(key)

        # Initial tree
        if self.node == None:
            self.node = n
            self.node.left = AVLTree()
            self.node.right = AVLTree()
        # Insert key to the left subtree
        elif key < self.node.key:
            self.node.left.insert(key)
        # Insert key to the right subtree
        elif key > self.node.key:
            self.node.right.insert(key)

        # Exit, key already exists in the tree
            
        # Rebalance tree if needed
        self.rebalance()
```

## Traversal

```python
    def inorder_traverse(self):
        """
        Inorder traversal of the tree
            Left subree + root + Right subtree
        """
        result = []

        if not self.node:
            return result
        
        result.extend(self.node.left.inorder_traverse())
        result.append(self.node.key)
        result.extend(self.node.right.inorder_traverse())

        return result
```

## Deletion
```python
    def delete(self, key):
        if self.node != None:
            if self.node.key == key:
                # Key found in leaf node, just erase it
                if not self.node.left.node and not self.node.right.node:
                    self.node = None
                # Node has only one subtree (right), replace root with that one
                elif not self.node.left.node:                
                    self.node = self.node.right.node
                # Node has only one subtree (left), replace root with that one
                elif not self.node.right.node:
                    self.node = self.node.left.node
                else:
                    # Find  successor as smallest node in right subtree or
                    #       predecessor as largest node in left subtree
                    successor = self.node.right.node  
                    while successor and successor.left.node:
                        successor = successor.left.node

                    if successor:
                        self.node.key = successor.key

                        # Delete successor from the replaced node right subree
                        self.node.right.delete(successor.key)

            elif key < self.node.key:
                self.node.left.delete(key)

            elif key > self.node.key:
                self.node.right.delete(key)

            # Rebalance tree
            self.rebalance()

```

## Rebalance

``` python
 def rebalance(self):
```

# B-Trees & B+ trees

## B-Trees

- Primarily used by relational databases
- Provides an efficient way to implement common database features such as *join,
  fast deletion and ordering of rows* 
- AVL is ideal for in-memory while B-Tree is made for disk-based storage

## Implementation

There are two types of way to implement a B-Tree
- Iterative
- Recursive

## Some key implementation details



```{r child="footer.Rmd", include=FALSE}
```
