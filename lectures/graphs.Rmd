---
title: "Graphs"
author: "Pavel Kucherbaev"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: revealjs::revealjs_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(GGally)
library(network)
library(sna)
library(ggplot2)
#library(igraph)
library(visNetwork) 
library(reticulate)
library(geomnet)
library(ggnetwork)
knitr::knit_engines$set(python = reticulate::eng_python)

# http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

# Introduction to Graphs

## Part 1: Outline
- What is a graph
- Directions and cycles
- Graph representation


## Not about

### Charts and Grafs
![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Graph_%28PSF%29.png/800px-Graph_%28PSF%29.png){ width=20% } ![](https://upload.wikimedia.org/wikipedia/en/4/46/DraculaWaxMuseum.JPG){ width=30% }

## Nodes represent objects

(e.g. people, cities, countries, computers).

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
# make data accessible
data(blood, package = "geomnet")

set.seed(12252016)
ggnet2(network::network(blood$edges[, 1:2], directed=F), 
       mode = "circle", size = 15, label = F, 
       arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       edge.color = "white", node.color = "darkred", label.color = "grey80")
# https://cran.r-project.org/web/packages/ggCompNet/vignettes/examples-from-paper.html
```

Nodes can be called vertices as well.


## Edges represent relationships

(e.g. friendship, connectedness)

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
set.seed(12252016)
ggnet2(network::network(blood$edges[, 1:2], directed=F), 
       mode = "circle", size = 15, label = F, 
       arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```

## Direction of relationships

(e.g. A follows B, A is a student of B)

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
set.seed(12252016)
ggnet2(network::network(blood$edges[, 1:2], directed=T), 
       mode = "circle", size = 15, label = F, 
       arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```

Does it remind you something?

## Blood donation

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
set.seed(12252016)
ggnet2(network::network(blood$edges[, 1:2], directed=T), 
       mode = "circle", size = 15, label = T, 
       arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```

## Position of nodes
```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 10, fig.height = 4}

set.seed(12252016)
p1 <- ggnet2(network::network(blood$edges[, 1:2], directed=T), 
       mode = "circle", size = 7, label.size = 3, label = T, 
       arrow.size = 5, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
p2 <- ggnet2(network::network(blood$edges[, 1:2], directed=T), 
       mode = "fruchtermanreingold", size = 7, label.size = 3,label = T, 
       arrow.size = 5, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
p3 <- ggnet2(network::network(blood$edges[, 1:2], directed=T), 
       mode = "circrand", size = 7, label.size = 3,label = T, 
       arrow.size = 5, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
p4 <- ggnet2(network::network(blood$edges[, 1:2], directed=T), 
       mode = "kamadakawai", size = 7, label.size = 3,label = T, 
       arrow.size = 5, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
multiplot(p1, p2, p3, p4, cols=2)
```

Does not change semantics of the graph

## Weights

(e.g. cost of travel, distance, energy to transition)

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}

set.seed(123234)
m <- matrix(rnorm(25,2,2),5,5)
m <- round(m)
diag(m) <- 0
m[lower.tri(m)] <- 0
net <- network(m, directed=F, names.eval = "weights", ignore.eval = FALSE)

ggnet2(net, 
       mode = "circle", size = 15, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80", edge.label = "weights", edge.label.color = "black")
# arrow.size = 10, arrow.gap = 0.05, 
```

In a directional graph cost in one direction could be different than back (e.g. going up hill and downhill).

## Graph representation

We can define a graph using:

- Edge list
- Adjacency list
- Adjacency matrix


## Edge list

[Edge1, Edge2, Edge3, Edge4]

Edge1 = [Node1, Node2]

```{python, echo = TRUE}

edge_list = [[0,1],[1,2],[1,3],[2,3]]

```

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}

m <- matrix(
  c(0, 1, 0, 0,
    1, 0, 1, 1,
    0, 1, 0, 1,
    0, 1, 1, 0),
  nrow = 4, ncol = 4
)
rownames(m) = c(0,1,2,3)
colnames(m) = c(0,1,2,3)

net <- network(m, directed=F, names.eval = "weights", ignore.eval = FALSE)

ggnet2(net, 
       mode = "circle", size = 15, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```




## Adjacency list

[Node1Conns, Node2Conns, Node3Conns, Node4Conns]

Node1Conns = [Node2, Node3]

```{python, echo = TRUE}

adj_list = [[1],[0,2,3],[1,3],[1,2]]

```

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
ggnet2(net, 
       mode = "circle", size = 15, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```


## Adjacency list

More efficient storage options for sparce graphs

```{python, echo = TRUE}

adj_list = [[1],[0,2,3],[1,3],[1,2],[],[],[],[],[],[],[],[],[],[]]


adj_dict = {
  "v0": ["v1"],
  "v1": ["v0","v2","v3"],
  "v2": ["v1","v3"],
  "v3": ["v1","v2"]
}


adj_dict_weights = {
  "v0": {"v1":1},
  "v1": {"v0":1,"v2":1,"v3":1},
  "v2": {"v1":1,"v3":1},
  "v3": {"v1":1,"v2":1}
}
```


## Adjacency matrix

Column names = Nodes, Row names = Nodes, Cells = Edges

```{python, echo = TRUE}

adj_matrix = [
[0, 1, 0, 0],
[1, 0, 1, 1],
[0, 1, 0, 1],
[0, 1, 1, 0],
]

```

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 5, fig.height = 3}
ggnet2(net, 
       mode = "circle", size = 10, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```

## Adjacency matrixxw

Non directional graph.

Cells are symmetrical across the main diagonal.

```{python, echo = TRUE}

adj_matrix = [
[0, 1, 0, 0],
[1, 0, 1, 1],
[0, 1, 0, 1],
[0, 1, 1, 0],
]

```

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 5, fig.height = 3}
ggnet2(net, 
       mode = "circle", size = 10, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
```

## Adjacency matrix

Directional graph. 

```{python, echo = TRUE}

adj_matrix = [
[0, 1, 0, 0],
[1, 0, 1, 1],
[1, 0, 0, 1],
[0, 0, 0, 0],
]

```

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 5, fig.height = 3}
m <- matrix(
  c(0, 1, 1, 0,
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 1, 1, 0),
  nrow = 4, ncol = 4
)
rownames(m) = c(0,1,2,3)
colnames(m) = c(0,1,2,3)

net <- network(m, directed=T, names.eval = "weights", ignore.eval = FALSE)


ggnet2(net, 
       mode = "circle", size = 10, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80", arrow.size = 10, arrow.gap = 0.05)
```

## Adjacency matrix

Directional graph with weights. 

```{python, echo = TRUE}

adj_matrix = [
[0, 1, 0, 0],
[1, 0, 3, 1],
[2, 0, 0, 1],
[0, 0, 0, 0],
]

```

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 5, fig.height = 3}
m <- matrix(
  c(0, 1, 2, 0,
    1, 0, 0, 0,
    0, 3, 0, 0,
    0, 1, 1, 0),
  nrow = 4, ncol = 4
)
rownames(m) = c(0,1,2,3)
colnames(m) = c(0,1,2,3)

net <- network(m, directed=T, names.eval = "weights", ignore.eval = FALSE)


ggnet2(net, 
       mode = "circle", size = 10, label = T, 
       vjust = 0.5, edge.label = "weights",
       node.color = "darkred", label.color = "grey80", arrow.size = 10, arrow.gap = 0.05)
```

## Traversal

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
ggnet2(net, 
       mode = "circle", size = 15, label = T, 
       vjust = 0.5,
       node.color = "darkred", label.color = "grey80", edge.label = "weights", edge.label.color = "black")
```

## Cycle

```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
set.seed(123)
m <- matrix(rnorm(25,2,2),5,5)
m <- round(m)
diag(m) <- 0
m[lower.tri(m)] <- 0

ggnet2(net, 
       mode = "circle", size = 15, label = T, 
       arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80", edge.label = "weights", edge.label.color = "black")
```

Trees can not have cycles. Graphs can have cycles.

## Path: Eulerian


```{r,  message=FALSE, warning=FALSE, cache=FALSE, fig.width = 7, fig.height = 4}
ggnet2(net, 
       mode = "circle", size = 15, label = T, 
       arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80", edge.label = "weights", edge.label.color = "black")
```


## DAG

Directed Acyclic Graph


## Part 2: Outline
- Euler path, Hamiltonian path
- Types of graphs
- Centrality (e.g. betweenness, closeness, eigenvector, node)



# Search Algorithms for Graphs

## Part 1
- Bredth-first search
- Depth-first search

## Part 2
- Shortest path. Dijkstra algorithm.
- All-pairs shortest path.
- Recap of the material

## References

- https://classroom.udacity.com/courses/cs215/
- https://classroom.udacity.com/courses/ud513/
- the book Introduction to algorithms
- https://briatte.github.io/ggnet/
- http://kateto.net/network-visualization
- https://www.udacity.com/wiki/creating-network-graphs-with-python
- http://www.kateto.net/wp-content/uploads/2016/01/NetSciX_2016_Workshop.pdf
- https://rstudio-pubs-static.s3.amazonaws.com/74248_3bd99f966ed94a91b36d39d8f21e3dc3.html


