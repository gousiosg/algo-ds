---
title: "Strings"
author: "Georgios Gousios"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: revealjs::revealjs_presentation
bibliography: bibliography.bib
csl: ieee.csl
nocite: |
  @Hutto99
---

```{r child="header.Rmd", include=FALSE}
```

## What is a string?

* **In math**: A _string_ is a finite sequence of symbols that are chosen from a
set called an _alphabet_.

* **In CS**: A _string_ is a sequence of characters.

What is the alphabet for strings in CS?

## Alphabets or encodings

In computer memory, strings are nothing more that binary data.

## Typical String Encodings

* **1-byte** encodings: EBCDIC and **ASCII**
* **2-byte** encodings: CJK (for logographic languages), Shift-JIS
* **n-byte** encodings: Unicode **UTF-8**

## ASCII

ASCII was originally a 7-bit encoding.

![The ASCII character table](./figures/ascii.png)

## Fun with ASCII

ASCII characters are representable as numbers. This means that
we can do arithmetic on them. 

```c
#include<stdio.h>

main() {
    for (int i = 0; i < 128; i++)
      printf("%c ", i);

    printf("%d\n", c);    

    for (int i = 128; i < 256; i++)
      printf("%c ", i);
}
```

![The ASCII character table](./figures/ascii-printout.png){width=70%}

## ISO-8859-*

To accomodate different languages with characters in non-Latin scripts, or
special characters (e.g. Ã¸, ÃŸ, Ã§) in Latin-based languages,
ASCII was extended with an 8th bit.

This allowed operating systems in most of the world (non-logographic languages) to use
the American string representation as a basis and only customize encodings when
the extra characters where required.

**Q:** What problems did this create?

. . .

A file encoded in ISO-8859-7 (Greek) could not be read 
correctly in a computer configured with ISO-8859-1 (Latin-1).

![Encodings](figures/encodings.png)


## Unicode

The world has around 7k languages and 3.8k writing systems. Unicode is an
effort to specify 1 string/data encoding scheme for everything.
The latest version contains a repertoire of 136,755 characters covering 
139 modern and historic scripts, as well as multiple symbol sets (e.g. music,
math, emoji). 

Unicode defines a lookup table between a unique character ID and a character
name / description

* 01E8 Ç¨ LATIN CAPITAL LETTER K WITH CARON
* 0E57 à¹— THAI DIGIT SEVEN
* 1F638 ðŸ˜¸ GRINNING CAT FACE WITH SMILING EYES

## UTF-8

To represent Unicode symbols as binary data, we need to encode binary data using
a format. We can thus use either _fixed length_ or _variable length_ encodings.
The most common format for Unicode files is UTF-8, developed by 
[Ken Tompson](https://en.wikipedia.org/wiki/Ken_Thompson) 
and [Rob Pike](https://en.wikipedia.org/wiki/Rob_Pike). 
 
In UTF-8, the most common characters are encoded with less bits than more
rare ones.

* First 128 characters need 1 byte
 
 
## Classes of problems on strings

Most problems with strings have to do with search a string or a list of
strings/patterns in another string.

* **String search:** Given a string, find the first/all occurences of it in another string
* **Regular expressions:** Given a _pattern_, find all its occurences in a string
* **Approximate matching:** How similar are two strings?
* **Edit script:** What is the minimal set of additions/deletions to go from one string to another?

---

## The string search problem

Given a text $T$ and a pattern $P$, find all occurrences of $P$ within $T$.

$T = AGCATGCTGCAGTCATGCTTAGGCTA$
$P = GCT$

**Q:** How many times does $P$ occur in $T$

. . .

The answer 3. But how did you search for it?

## Naive string search
Say that we are searching for $P=$`ABC` in string $T=$`ABABABACCABC`.

```
  ABABABACCABC
1 ABX               (first two characters match, last does not)
2  X                (first character doesn't match)
3   ABX             (first two characters match, last does not)
4    X              (first character doesn't match)
5     ABX           (first two characters match, last does not)
6      X            (first character doesn't match)
7       AX          (first character matches, second doesn't)
8        X          (first character doesn't match)
9         X         (first character doesn't match)
10         ABC      (match found)
```

The brute force approach is $O(mn)$, whe $m = len(T)$ and $n = len(P)$.

A step 2, we are restarting the search at a character we _know_ it won't match.
We should instead start from step 4.

## How can we be more efficient?

_Idea:_ How about we build a lookup table of the lengths of _prefixes_ in $P$
that are also _suffixes_? Then, we can use that to jump ahead in our search 
if we get a mismatch!

|pattern          | a | b | a | b | a | c |
|-----------------|---|---|---|---|---|---|
| j               | 0 | 1 | 2 | 3 | 4 | 5 |
|Prefix: $P[0:j]$ | a | ab| aba | abab | ababa | ababac | 
|Prefix - Suffix  | $\emptyset$ | $\emptyset$ | a | ab | aba | $\emptyset$
|$p[i]$           | 0 | 0 | 1 | 2 | 3 | 0 |

This table is used to calculate where to jump to in $T$ in case of a 
mismatch of character position $i$ in $P$. The new position should be
$cur + i - jump[i]$, 
 

## The Knuth-Morris-Pratt algorithm

**Q**: Let `T = ABC ABCDAB ABCDABCDABDE` and `P = ABCDABD`. What is jump table?

. . .

`j = [0,0,0,0,1,2,0]`

. . .

```
T: ABC ABCDAB ABCDABCDABDE
P: ABCDABD
      |
      mismatch
```

Step **1**: We matched $k = 3$ letters so far and $j[k] = 0$. So we can jump by $k - j[k] = 3$
letters ahead:

```
T: ABC ABCDAB ABCDABCDABDE
P:    ABCDABD
      |
      mismatch
```

Step **2**: We matched $k = 0$ letters, $j[0] = -1$. So we can jump by $k - j[k] = 1$ letter

```
T: ABC ABCDAB ABCDABCDABDE
P:     ABCDABD
             |
             mismatch
```

Step **3**: We matched $k = 6$ letters, $j[6] = 2$. So we can jump by $k - j[k] = 4$ letters

```
T: ABC ABCDAB ABCDABCDABDE
P:         ABCDABD
             |
             mismatch
```

Step **4**: We matched $k = 2$ letters, $j[2] = 0$. So we can jump by $k - j[k] = 2$ letters

```
T: ABC ABCDAB ABCDABCDABDE
P:           ABCDABD
             |
             mismatch
```

Step **5**: We matched $k = 0$ letters, $j[0] = -1$. So we can jump by $k - j[k] = 1$ letters

```
T: ABC ABCDAB ABCDABCDABDE
P:            ABCDABD
                    |
                    mismatch
```

Step **6**: We matched $k = 6$ letters, $j[6] = 2$. So we can jump by $k - j[k] = 4$ letters

```
T: ABC ABCDAB ABCDABCDABDE
P:                ABCDABD
                
                    success!
```

The example above was adapted from [Jaehyun Park's String Algorithms lecture](https://web.stanford.edu/class/cs97si/10-string-algorithms.pdf)



## Calculating the jump table

```python
def jump_table(pattern):
  result = [None]

  for i in range(0, len(pattern)):
    j = i

    while True:
      if j == 0:
        result.append(0)
          break

      if pattern[result[j]] == pattern[i]:
        result.append(result[j] + 1)
          break
      j = result[j]
  return result
```

The complexity of the jump table calculator is $O(m)$

## KMP in Python

```python
def kmp(P, T):
    jump = jump_table(P)

    index = 0
    match = 0

    while index + match < len(T):
        if T[index + match] == P[match]:
            match = match + 1

            if match == len(P):
                return index
        else:
            if match == 0:
                index = index + 1
            else:
                index = index + match - jump[match]
                match = jump[match]

    return None
```

The complexity of KMP is $O(n)$; the overall complexity of applying KMP is
$O(m) + O(n)$, which is much better than the brute force's $O(mn)$.

---

## Regular expressions


It is often not enough to detect 
* **.** Match any character once
* `*` Match the previous pattern 0 or more times
* **+** Match the previous pattern 1 or more times
* **[e-fF-M]** Match any character in the (ASCII) range `F-M` or `e-f`
* **[^e]** Match all characters _except_ e
* **^** and **$** Match the beginning or the end of the line, respectively
* **()** Group together items for future reference
* **|** Match either the left or the right group

## Levenstein distance

$$
\qquad\operatorname{lev}_{a,b}(i,j) = \begin{cases}
  \max(i,j) & \text{ if} \min(i,j)=0, \\
  \min \begin{cases}
          \operatorname{lev}_{a,b}(i-1,j) + 1 \\
          \operatorname{lev}_{a,b}(i,j-1) + 1 \\
          \operatorname{lev}_{a,b}(i-1,j-1) + 1_{(a_i \neq b_j)}
       \end{cases} & \text{ otherwise.}
\end{cases}
$$

## RContent credit

* [Knuth-Morris-Pratt algorithm](https://gist.github.com/Nicksil/5646003), by Nicksil

* [String Algorithms](https://web.stanford.edu/class/cs97si/10-string-algorithms.pdf), by Jaehyun Park
```{r child="footer.Rmd", include=FALSE}
```
